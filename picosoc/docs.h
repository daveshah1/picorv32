const char *docs_text = "\n"
"\n"
"Project IceStorm\n"
"\n"
"2017-03-13: Released support for LP384 chips (in all package variants).\n"
"2016-02-07: Support for all package variants of LP1K, LP4K, LP8K and HX1K,\n"
"HX4K, and HX8K.\n"
"2016-01-17: First release of IceTime timing analysis. Video: https://youtu.be/\n"
"IG5CpFJRnOk\n"
"2015-12-27: Presentation of the IceStorm flow at 32C3 (Video_on_Youtube).\n"
"2015-07-19: Released support for 8k chips. Moved IceStorm source code to\n"
"GitHub.\n"
"2015-05-27: We have a working fully Open Source flow with Yosys and Arachne-\n"
"pnr! Video: http://youtu.be/yUiNlmvVOq8\n"
"2015-04-13: Complete rewrite of IceUnpack, added IcePack, some major\n"
"documentation updates\n"
"2015-03-22: First public release and short YouTube video demonstrating our\n"
"work: http://youtu.be/u1ZHcSNDQMM\n"
"\n"
"What is Project IceStorm?\n"
"\n"
"Project IceStorm aims at reverse engineering and documenting the bitstream\n"
"format of Lattice iCE40 FPGAs and providing simple tools for analyzing and\n"
"creating bitstream files. The IceStorm flow (Yosys, Arachne-pnr, and IceStorm)\n"
"is a fully open source Verilog-to-Bitstream flow for iCE40 FPGAs.\n"
"The focus of the project is on the iCE40 LP/HX 1K/4K/8K chips. (Most of the\n"
"work was done on HX1K-TQ144 and HX8K-CT256 parts.)\n"
"\n"
"Why the Lattice iCE40?\n"
"\n"
"It has a very minimalistic architecture with a very regular structure. There\n"
"are not many different kinds of tiles or special function units. This makes it\n"
"both ideal for reverse engineering and as a reference platform for general\n"
"purpose FPGA tool development.\n"
"Also, with the Lattice_iCEstick there is a cheap and easy to use development\n"
"platform available, which makes the part interesting for all kinds of projects.\n"
"(The iCEstick features an HX1K device. Lattice also sells an iCE40-HX8K\n"
"Breakout_Board featuring an HX8K chip.)\n"
"\n"
"What is the Status of the Project?\n"
"\n"
"We are pretty confident that we have the 1K and 8K devices completely reverse\n"
"engineered. For example, it seems we can create correct functional Verilog\n"
"models for all bitstreams generated by Lattice iCEcube2 for the iCE40 HX1K-\n"
"TQ144 and the iCE40 HX8K-CT256 using our icebox_vlog tool.\n"
"Here is a list of currently supported parts and the corresponding options for\n"
"arachne-pnr (place and route) and icetime (timing analysis):\n"
"\n"
"Part            Package          Pin Spacing I/Os arachne-pnr opts icetime opts\n"
"iCE40-LP1K-     16-ball WLCSP    0.35 mm     10   -d 1k -P swg16tr -d lp1k\n"
"SWG16TR         (1.40 x 1.48 mm)\n"
"iCE40-LP384-    36-ball ucBGA    0.40 mm     25   -d 384 -P cm36   -d lp384\n"
"CM36            (2.5 x 2.5 mm)\n"
"iCE40-LP1K-CM36 36-ball ucBGA    0.40 mm     25   -d 1k -P cm36    -d lp1k\n"
"                (2.5 x 2.5 mm)\n"
"iCE40-LP384-    49-ball ucBGA (3 0.40 mm     37   -d 384 -P cm49   -d lp384\n"
"CM49            x 3 mm)\n"
"iCE40-LP1K-CM49 49-ball ucBGA (3 0.40 mm     35   -d 1k -P cm49    -d lp1k\n"
"                x 3 mm)\n"
"iCE40-LP1K-CM81 81-ball ucBGA (4 0.40 mm     63   -d 1k -P cm81    -d lp1k\n"
"                x 4 mm)\n"
"iCE40-LP4K-CM81 81-ball ucBGA (4 0.40 mm     63   -d 8k -P cm81:4k -d lp8k\n"
"                x 4 mm)\n"
"iCE40-LP8K-CM81 81-ball ucBGA (4 0.40 mm     63   -d 8k -P cm81    -d lp8k\n"
"                x 4 mm)\n"
"iCE40-LP1K-     121-ball ucBGA   0.40 mm     95   -d 1k -P cm121   -d lp1k\n"
"CM121           (5 x 5 mm)\n"
"iCE40-LP4K-     121-ball ucBGA   0.40 mm     93   -d 8k -P cm121:  -d lp8k\n"
"CM121           (5 x 5 mm)                        4k\n"
"iCE40-LP8K-     121-ball ucBGA   0.40 mm     93   -d 8k -P cm121   -d lp8k\n"
"CM121           (5 x 5 mm)\n"
"iCE40-LP4K-     225-ball ucBGA   0.40 mm     167  -d 8k -P cm225:  -d lp8k\n"
"CM225           (7 x 7 mm)                        4k\n"
"iCE40-LP8K-     225-ball ucBGA   0.40 mm     178  -d 8k -P cm225   -d lp8k\n"
"CM225           (7 x 7 mm)\n"
"iCE40-HX8K-     225-ball ucBGA   0.40 mm     178  -d 8k -P cm225   -d hx8k\n"
"CM225           (7 x 7 mm)\n"
"iCE40-LP384-    32-pin QFN (5 x  0.50 mm     21   -d 384 -P qn32   -d lp384\n"
"QN32            5 mm)\n"
"iCE40-LP1K-QN84 84-pin QFNS (7 x 0.50 mm     67   -d 1k -P qn84    -d lp1k\n"
"                7 mm)\n"
"iCE40-LP1K-CB81 81-ball csBGA (5 0.50 mm     62   -d 1k -P cb81    -d lp1k\n"
"                x 5 mm)\n"
"iCE40-LP1K-     121-ball csBGA   0.50 mm     92   -d 1k -P cb121   -d lp1k\n"
"CB121           (6 x 6 mm)\n"
"iCE40-HX1K-     132-ball csBGA   0.50 mm     95   -d 1k -P cb132   -d hx1k\n"
"CB132           (8 x 8 mm)\n"
"iCE40-HX4K-     132-ball csBGA   0.50 mm     95   -d 8k -P cb132:  -d hx8k\n"
"CB132           (8 x 8 mm)                        4k\n"
"iCE40-HX8K-     132-ball csBGA   0.50 mm     95   -d 8k -P cb132   -d hx8k\n"
"CB132           (8 x 8 mm)\n"
"iCE40-HX1K-     100-pin VQFP (14 0.50 mm     72   -d 1k -P vq100   -d hx1k\n"
"VQ100           x 14 mm)\n"
"iCE40-HX1K-     144-pin TQFP (20 0.50 mm     96   -d 1k -P tq144   -d hx1k\n"
"TQ144           x 20 mm)\n"
"iCE40-HX4K-     144-pin TQFP (20 0.50 mm     107  -d 8k -P tq144:  -d hx8k\n"
"TQ144           x 20 mm)                          4k\n"
"iCE40-HX8K-     256-ball caBGA   0.80 mm     206  -d 8k -P ct256   -d hx8k\n"
"CT256           (14 x 14 mm)\n"
"\n"
"Current work focuses on further improving our timing analysis flow.\n"
"\n"
"How do I use the Fully Open Source iCE40 Flow?\n"
"\n"
"Synthesis for iCE40 FPGAs can be done with Yosys. Place-and-route can be done\n"
"with arachne-pnr. Here is an example script for implementing and programming\n"
"the rot_example_from_arachne-pnr (this example targets the iCEstick development\n"
"board):\n"
"\n"
"  yosys -p \"synth_ice40 -blif rot.blif\" rot.v\n"
"  arachne-pnr -d 1k -p rot.pcf rot.blif -o rot.asc\n"
"  icepack rot.asc rot.bin\n"
"  iceprog rot.bin\n"
"\n"
"A simple timing analysis report can be generated using the icetime utility:\n"
"\n"
"  icetime -tmd hx1k rot.asc\n"
"\n"
"\n"
"Where are the Tools? How to install?\n"
"\n"
"Installing prerequisites (this command is for Ubuntu 14.04):\n"
"\n"
"  sudo apt-get install build-essential clang bison flex libreadline-dev \\\n"
"                       gawk tcl-dev libffi-dev git mercurial graphviz   \\\n"
"                       xdot pkg-config python python3 libftdi-dev\n"
"\n"
"On Fedora 24 the following command installs all prerequisites:\n"
"\n"
"  sudo dnf install make automake gcc gcc-c++ kernel-devel clang bison \\\n"
"                   flex readline-devel gawk tcl-devel libffi-devel git\n"
"  mercurial \\\n"
"                   graphviz python-xdot pkgconfig python python3 libftdi-devel\n"
"\n"
"Installing the IceStorm_Tools (icepack, icebox, iceprog, icetime, chip\n"
"databases):\n"
"\n"
"  git clone https://github.com/cliffordwolf/icestorm.git icestorm\n"
"  cd icestorm\n"
"  make -j$(nproc)\n"
"  sudo make install\n"
"\n"
"Installing Arachne-PNR (the place&route tool):\n"
"\n"
"  git clone https://github.com/cseed/arachne-pnr.git arachne-pnr\n"
"  cd arachne-pnr\n"
"  make -j$(nproc)\n"
"  sudo make install\n"
"\n"
"Installing Yosys (Verilog synthesis):\n"
"\n"
"  git clone https://github.com/cliffordwolf/yosys.git yosys\n"
"  cd yosys\n"
"  make -j$(nproc)\n"
"  sudo make install\n"
"\n"
"The Arachne-PNR build converts the IceStorm text chip databases into the\n"
"arachne-pnr binary chip databases. Always rebuild Arachne-PNR after updating\n"
"your IceStorm installation.\n"
"Notes for Linux: Create a file /etc/udev/rules.d/53-lattice-ftdi.rules with the\n"
"following line in it to allow uploading bit-streams to a Lattice iCEstick and/\n"
"or a Lattice iCE40-HX8K Breakout Board as unprivileged user:\n"
"\n"
"  ACTION==\"add\", ATTR{idVendor}==\"0403\", ATTR{idProduct}==\"6010\", MODE:=\"666\"\n"
"\n"
"Notes for Archlinux: just install icestorm-git, arachne-pnr-git and yosys-git\n"
"from the Arch User Repository (no need to follow the install instructions\n"
"above).\n"
"Notes for OSX: Please follow the additional_instructions_for_OSX to install on\n"
"OSX.\n"
"Please file_an_issue_on_github if you have additional notes to share regarding\n"
"the install procedures on the operating system of your choice.\n"
"\n"
"What are the IceStorm Tools?\n"
"\n"
"The IceStorm Tools are a couple of small programs for working with iCE40\n"
"bitstream files and our ASCII representation of it. The complete Open Source\n"
"iCE40 Flow consists of the IceStorm_Tools, Arachne-PNR, and Yosys.\n"
"\n"
"IcePack/IceUnpack\n"
"\n"
"The iceunpack program converts an iCE40 .bin file into the IceStorm ASCII\n"
"format that has blocks of 0 and 1 for the config bits for each tile in the\n"
"chip. The icepack program converts such an ASCII file back to an iCE40 .bin\n"
"file. All other IceStorm Tools operate on the ASCII file format, not the\n"
"bitstream binaries.\n"
"\n"
"IceTime\n"
"\n"
"The icetime program is an iCE40 timing analysis tool. It reads designs in\n"
"IceStorm ASCII format and writes times timing netlists that can be used in\n"
"external timing analysers. It also includes a simple topological timing\n"
"analyser that can be used to create timing reports.\n"
"\n"
"IceBox\n"
"\n"
"A python library and various tools for working with IceStorm ASCII files and\n"
"accessing the device database. For example icebox_vlog converts our ASCII file\n"
"dump of a bitstream into a Verilog file that implements an equivalent circuit.\n"
"\n"
"IceProg\n"
"\n"
"A small driver program for the FTDI-based programmer used on the iCEstick and\n"
"HX8K development boards.\n"
"\n"
"IceMulti\n"
"\n"
"A tool for packing multiple bitstream files into one iCE40 multiboot image\n"
"file.\n"
"\n"
"IcePLL\n"
"\n"
"A small program for calculating iCE40 PLL configuration parameters.\n"
"\n"
"IceBRAM\n"
"\n"
"A small program for swapping the BRAM contents in IceStorm ASCII files. E.g.\n"
"for changing the firmware image in a SoC design without re-running synthesis\n"
"and place&route.\n"
"\n"
"ChipDB\n"
"\n"
"The IceStorm Makefile builds and installs two files: chipdb-1k.txt and chipdb-\n"
"8k.txt. This files contain all the relevant information for arachne-pnr to\n"
"place&route a design and create an IceStorm ASCII file for the placed and\n"
"routed design.\n"
"IcePack/IceUnpack, IceBox, IceProg, IceTime, and IcePLL are written by Clifford\n"
"Wolf. IcePack/IceUnpack is based on a reference implementation provided by\n"
"Mathias Lasser. IceMulti is written by Marcus Comstedt.\n"
"\n"
"Where do I get support or meet other IceStorm users?\n"
"\n"
"If you have a question regarding the IceStorm flow, use the yosys_tag_on\n"
"stackoverflow to ask your question. If your question is a general question\n"
"about Verilog HDL design, please consider using the verilog_tag_on\n"
"stackoverflow instead.\n"
"For general discussions go to the Yosys_Subreddit or #yosys_on_freenode_IRC.\n"
"If you have a bug report please file an issue on github. (IceStorm_Issue\n"
"Tracker, Yosys_Issue_Tracker, Arachne-PNR_Issue_Tracker)\n"
"\n"
"Where is the Documentation?\n"
"\n"
"Recommended reading: Lattice_iCE40_LP/HX_Family_Datasheet, Lattice_iCE\n"
"Technology_Library (Especially the three pages on \"Architecture Overview\", \"PLB\n"
"Blocks\", \"Routing\", and \"Clock/Control Distribution Network\" in the Lattice\n"
"iCE40 LP/HX Family Datasheet. Read that first, then come back here.)\n"
"The FPGA fabric is divided into tiles. There are IO, RAM and LOGIC tiles.\n"
"\n"
"* LOGIC_Tile_Documentation\n"
"* IO_Tile_Documentation\n"
"* RAM_Tile_Documentation\n"
"* The_Bitstream_File_Format\n"
"* The_iCE40_HX1K_Bit_Docs\n"
"* The_iCE40_HX8K_Bit_Docs\n"
"\n"
"The iceunpack program can be used to convert the bitstream into an ASCII file\n"
"that has a block of 0 and 1 characters for each tile. For example:\n"
"\n"
"  .logic_tile 12 12\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000011010000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000001011000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000000000000000000000000000000000\n"
"  000000000000000000000000001000001000010101010000000000\n"
"  000000000000000000000000000101010000101010100000000000\n"
"\n"
"This bits are referred to as By[x] in the documentation. For example, B0 is the\n"
"first line, B0[0] the first bit in the first line, and B15[53] the last bit in\n"
"the last line.\n"
"The icebox_explain program can be used to turn this block of config bits into a\n"
"description of the cell configuration:\n"
"\n"
"  .logic_tile 12 12\n"
"  LC_7 0101010110101010 0000\n"
"  buffer local_g0_2 lutff_7/in_3\n"
"  buffer local_g1_4 lutff_7/in_0\n"
"  buffer sp12_h_r_18 local_g0_2\n"
"  buffer sp12_h_r_20 local_g1_4\n"
"\n"
"IceBox contains a database of the wires and configuration bits that can be\n"
"found in iCE40 tiles. This database can be accessed via the IceBox Python API.\n"
"But IceBox is a large hack. So it is recommended to only use the IceBox API to\n"
"export this database into a format that fits the target application. See\n"
"icebox_chipdb for an example program that does that.\n"
"The recommended approach for learning how to use this documentation is to\n"
"synthesize very simple circuits using Yosys and Arachne-pnr, run the icestorm\n"
"tool icebox_explain on the resulting bitstream files, and analyze the results\n"
"using the HTML export of the database mentioned above. icebox_vlog can be used\n"
"to convert the bitstream to Verilog. The output file of this tool will also\n"
"outline the signal paths in comments added to the generated Verilog code.\n"
"For example, consider the following Verilog and PCF files:\n"
"\n"
"  // example.v\n"
"  module top (input a, b, output y);\n"
"    assign y = a & b;\n"
"  endmodule\n"
"\n"
"  # example.pcf\n"
"  set_io a 1\n"
"  set_io b 10\n"
"  set_io y 11\n"
"\n"
"And run them through Yosys, Arachne-PNR and IcePack:\n"
"\n"
"  $ yosys -p 'synth_ice40 -top top -blif example.blif' example.v\n"
"  $ arachne-pnr -d 1k -o example.asc -p example.pcf example.blif\n"
"  $ icepack example.asc example.bin\n"
"\n"
"We would get something like the following icebox_explain output:\n"
"\n"
"  $ icebox_explain example.asc\n"
"  Reading file 'example.asc'..\n"
"  Fabric size (without IO tiles): 12 x 16\n"
"\n"
"  .io_tile 0 10\n"
"  IOB_1 PINTYPE_0\n"
"  IOB_1 PINTYPE_3\n"
"  IOB_1 PINTYPE_4\n"
"  IoCtrl IE_0\n"
"  IoCtrl IE_1\n"
"  IoCtrl REN_0\n"
"  buffer local_g0_5 io_1/D_OUT_0\n"
"  buffer logic_op_tnr_5 local_g0_5\n"
"\n"
"  .io_tile 0 14\n"
"  IOB_1 PINTYPE_0\n"
"  IoCtrl IE_1\n"
"  IoCtrl REN_0\n"
"  buffer io_1/D_IN_0 span4_vert_b_6\n"
"\n"
"  .io_tile 0 11\n"
"  IOB_0 PINTYPE_0\n"
"  IoCtrl IE_0\n"
"  IoCtrl REN_1\n"
"  routing span4_vert_t_14 span4_horz_13\n"
"\n"
"  .logic_tile 1 11\n"
"  LC_5 0001000000000000 0000\n"
"  buffer local_g0_0 lutff_5/in_1\n"
"  buffer local_g3_0 lutff_5/in_0\n"
"  buffer neigh_op_lft_0 local_g0_0\n"
"  buffer sp4_h_r_24 local_g3_0\n"
"\n"
"And something like the following icebox_vlog output:\n"
"\n"
"  $ icebox_vlog -p example.pcf example.asc\n"
"  // Reading file 'example.asc'..\n"
"\n"
"  module chip (output y, input b, input a);\n"
"\n"
"  wire y;\n"
"  // io_0_10_1\n"
"  // (0, 10, 'io_1/D_OUT_0')\n"
"  // (0, 10, 'io_1/PAD')\n"
"  // (0, 10, 'local_g0_5')\n"
"  // (0, 10, 'logic_op_tnr_5')\n"
"  // (0, 11, 'logic_op_rgt_5')\n"
"  // (0, 12, 'logic_op_bnr_5')\n"
"  // (1, 10, 'neigh_op_top_5')\n"
"  // (1, 11, 'lutff_5/out')\n"
"  // (1, 12, 'neigh_op_bot_5')\n"
"  // (2, 10, 'neigh_op_tnl_5')\n"
"  // (2, 11, 'neigh_op_lft_5')\n"
"  // (2, 12, 'neigh_op_bnl_5')\n"
"\n"
"  wire b;\n"
"  // io_0_11_0\n"
"  // (0, 11, 'io_0/D_IN_0')\n"
"  // (0, 11, 'io_0/PAD')\n"
"  // (1, 10, 'neigh_op_tnl_0')\n"
"  // (1, 10, 'neigh_op_tnl_4')\n"
"  // (1, 11, 'local_g0_0')\n"
"  // (1, 11, 'lutff_5/in_1')\n"
"  // (1, 11, 'neigh_op_lft_0')\n"
"  // (1, 11, 'neigh_op_lft_4')\n"
"  // (1, 12, 'neigh_op_bnl_0')\n"
"  // (1, 12, 'neigh_op_bnl_4')\n"
"\n"
"  wire a;\n"
"  // io_0_14_1\n"
"  // (0, 11, 'span4_horz_13')\n"
"  // (0, 11, 'span4_vert_t_14')\n"
"  // (0, 12, 'span4_vert_b_14')\n"
"  // (0, 13, 'span4_vert_b_10')\n"
"  // (0, 14, 'io_1/D_IN_0')\n"
"  // (0, 14, 'io_1/PAD')\n"
"  // (0, 14, 'span4_vert_b_6')\n"
"  // (0, 15, 'span4_vert_b_2')\n"
"  // (1, 11, 'local_g3_0')\n"
"  // (1, 11, 'lutff_5/in_0')\n"
"  // (1, 11, 'sp4_h_r_24')\n"
"  // (1, 13, 'neigh_op_tnl_2')\n"
"  // (1, 13, 'neigh_op_tnl_6')\n"
"  // (1, 14, 'neigh_op_lft_2')\n"
"  // (1, 14, 'neigh_op_lft_6')\n"
"  // (1, 15, 'neigh_op_bnl_2')\n"
"  // (1, 15, 'neigh_op_bnl_6')\n"
"  // (2, 11, 'sp4_h_r_37')\n"
"  // (3, 11, 'sp4_h_l_37')\n"
"\n"
"  assign y = /* LUT    1 11  5 */ b ? a : 0;\n"
"\n"
"  endmodule\n"
"\n"
"\n"
"Links\n"
"\n"
"Links to related projects. Contact me at clifford@clifford.at if you have an\n"
"interesting and relevant link.\n"
"\n"
"* J1a_SwapForth_built_with_IceStorm\n"
"* Lattice_iCEBlink40_Programming_Tool\n"
"* Another_iCEBlink40_Programming_Tool\n"
"* iCE40_layout_viewer\n"
"* icedrom_iCE40_netlist_viewer\n"
"\n"
"\n"
"iCE40 Boards\n"
"\n"
"\n"
"* Lattice_iCEstick\n"
"* Lattice_iCE40-HX8K_Breakout_Board\n"
"* IcoBoard\n"
"* wiggleport\n"
"* ICEd_=_an_Arduino_Style_Board,_with_ICE_FPGA\n"
"* CAT_Board\n"
"* eCow-Logic_pico-ITX_Lattice_ICE40_board\n"
"* Nandland_Go_Board\n"
"* myStorm_board_(iCE40_+_STM32)\n"
"* DSP_iCE_board_(another_iCE40_+_STM32_board)\n"
"\n"
"\n"
"Lectures and Tutorials\n"
"\n"
"\n"
"* A_Free_and_Open_Source_Verilog-to-Bitstream_Flow_for_iCE40_FPGAs_[32c3]\n"
"* Synthesizing_Verilog_for_Lattice_ICE40_FPGAs_(Paul_Martin)\n"
"* A_Spanish_FPGA_Tutorial_using_IceStorm\n"
"\n"
"\n"
"Other FPGA reverse engineering projects\n"
"\n"
"\n"
"* Xilinx_xc6slx9_reverse_engineering,_Wolfgang_Spraul\n"
"* From_the_bitstream_to_the_netlist,_Jean-Baptiste_Note_and_Ã‰ric_Rannaud\n"
"* Cyclone_IV_EP4CE6_reverse_engineering,_Marek_Vasut\n"
"\n"
"-------------------------------------------------------------------------------\n"
"In papers and reports, please refer to Project IceStorm as follows: Clifford\n"
"Wolf, Mathias Lasser. Project IceStorm. http://www.clifford.at/icestorm/, e.g.\n"
"using the following BibTeX code:\n"
"\n"
"  @MISC{IceStorm,\n"
"  \tauthor = {Clifford Wolf and Mathias Lasser},\n"
"  \ttitle = {Project IceStorm},\n"
"  \thowpublished = \"\\url{http://www.clifford.at/icestorm/}\"\n"
"  }\n"
"\n"
"-------------------------------------------------------------------------------\n"
"Documentation mostly by Clifford Wolf <clifford@clifford.at> in 2015. Based on\n"
"research by Mathias Lasser and Clifford Wolf.\n"
"Buy an iCEstick or iCE40-HX8K_Breakout_Board from Lattice and see what you can\n"
"do with the tools and information provided here.\n"
"";